import { BaseFormatter } from './base';
import { TestCase } from 'app/common/model';
import { TestCaseFormatter } from 'selenium-protractor/lib/test-case-formatter';

export class ProtractorFormatter extends BaseFormatter {

  public endOfLine: string;
  public variableName: string;
  public marker: { start: string, end: string };
  private formatter;

  public constructor() {
    super();
    this.name = 'protractor';
    this.extension = '.ptor.js';
    this.endOfLine = navigator.platform === 'Win32' ? '\r\n' : '\n';
    this.variableName = 'TEST_CASE';
    this.marker = {
      start: '// PTOR:start',
      end: '// PTOR:end'
    };
  }

  public parse(content: string): TestCase {
    const starIndex = content.indexOf(this.marker.start);
    const endIndex = content.indexOf(this.marker.end);
    if (starIndex === -1 || endIndex === -1) {
      throw new Error('Header markers are missing, file cannot be parsed');
    }
    const firstCurlyBrace = content.indexOf('{', starIndex);
    const lastCurlyBrace = content.lastIndexOf('}', endIndex);
    if (firstCurlyBrace === -1 || lastCurlyBrace === -1) {
      throw new Error('file cannot be parsed');
    }
    const header = content.substr(firstCurlyBrace, lastCurlyBrace - firstCurlyBrace + 1);
    const result = JSON.parse(header);
    return result;
  }

  public stringify(testCase: TestCase): string {
    if (!this.formatter) {
      this.formatter = new TestCaseFormatter({ whitespace: '    ', endOfLine: this.endOfLine });
    }
    let header = this.marker.start + this.formatter.endOfLine;
    header += '// File was generated by Selenium Protractor' + this.formatter.endOfLine;
    header += 'var ' + this.variableName + ' = ' + JSON.stringify(testCase, undefined, 4) + ';' + this.formatter.endOfLine;
    header += this.marker.end + this.formatter.endOfLine.repeat(2);
    header += '// Do not modify anything below as changes will be lost!' + this.formatter.endOfLine.repeat(2);
    // there is a slight difference in the structure
    const initialCommands = [
      { type: 'export' },
      { type: 'desc', value: testCase.title }
    ]; // always mark test case for export and add initial desc block
    const body = this.formatter.stringify({
      commands: testCase.items.reduce((list, item, index) => {
        const result = {
          type: item.command || '',
          locator: item.locator || '',
          value: item.value || ''
        };
        // 2 subsequent comment gets converted to a desc and it command
        if (item.type === 'comment') {
          result.type = testCase.items[index + 1] && testCase.items[index + 1].type === 'comment' ? 'desc' : 'it';
        }
        list.push(result);
        return list;
      }, initialCommands)
    });

    return header + body;
  }
}
